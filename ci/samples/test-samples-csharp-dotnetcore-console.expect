#!/usr/bin/expect
#
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT license.
#

if {[llength $argv] < 2} {
  send_user "Usage: [file tail [info script]] inputDir cmd-relative-to-root...\n"
  exit 1
}

set inputDir [lindex $argv 0]
set cmd [lrange $argv 1 end]

set timeout 15

source [file join [file dirname [info script]] common.expect]

set testIndex 0
set testFailures 0

spawn {*}$cmd

foreach scenario [list \
  speech_recognize_once_from_mic \
  InvalidInput \
  speech_recognize_keyword_from_microphone \
  Stop \
] {
  incr testIndex
  send_user "\n### Running test [set testIndex] - scenario [set scenario]\n"

  expect {
    "Your choice (0: Stop): " {

      switch $scenario {

        Stop {
          send 0
          expect {
            timeout {
              send_user "### TIMEOUT waiting for EOF\n"
              incr testFailures
            }
            eof
          }
        }

        InvalidInput {
          send x
          expect {
            timeout {
              send_user "### TIMEOUT waiting for Invalid input.\n"
              incr testFailures
            }
            "Invalid input."
          }
        }

        speech_recognize_once_from_mic {
          send 1
          expect {
            "Say something...\r\n" {
              paplay $weatherWav

              expect {
                -re "RECOGNIZED: Text=(\[^\r]*)\r\n" {
                  assertTextEqual testFailures "reco text" $weatherText $expect_out(1,string)
                }
                timeout {
                  send_user "### TIMEOUT waiting for RECOGNIZED\n"
                  incr testFailures
                }
              }
            }
            timeout {
              send_user "### TIMEOUT waiting for 'Say something'\n"
              incr testFailures
            }
          }
        }

        speech_recognize_keyword_from_microphone {
          send 7
          # TODO do a negative reco also
          expect {
            "Say something starting with" {
              set maxAttempts 3
              for {set attempt 1} {$attempt <= $maxAttempts} {incr attempt} {
                send_user "### Attempt $attempt\n"
                paplay $kwsWeatherWav [expr $attempt*1300]

                expect {
                  -re "RECOGNIZED: Text=(\[^\r]*)\r\n" {
                    assertTextNormalizedEqual testFailures "reco text" $kwsWeatherText $expect_out(1,string)
                    break
                  }
                  "CANCELED: Reason=" {
                    incr testFailures
                    break
                  }
                  timeout {
                    send_user "### TIMEOUT waiting for RECOGNIZED/CANCELED\n"
                  }
                }
              }

              if {$attempt > $maxAttempts} {
                 # No way to stop the sample.
                 send_user "### Could not finish keyword-triggered recognition. Must stop.\n"
                 exit 1
              }
            }
            timeout {
              send_user "### TIMEOUT waiting for 'Say something'\n"
              incr testFailures
              # likely a fatal error
            }
          }
        }

        default {
          send_user "### invalid scenario, exiting\n"
          exit 1
        }
      }
    }
    timeout {
      # Didn't get the top-level prompt. Can't continue...
      send_user "### TIMEOUT waiting for prompt\n"
      exit 1
    }
  }
}

send_user "### Done -- [expr $testIndex - $testFailures]/$testIndex test(s) succeeded\n"

# Pick up error on program exit
lassign [wait] pid spawnid os_error_flag value
if {$os_error_flag == 0} {
  send_user "### sample exit status: $value\n"
  if {$value != 0} {
    send_user "### non-zero exit status\n"
    exit 1
  }
} else {
  send_user "### non-zero errno: $os_error_flag\n"
  exit 1
}

exit [set testFailures]

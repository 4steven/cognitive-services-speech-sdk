#!/usr/bin/expect
#
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT license.
#

if {[llength $argv] < 2} {
  send_user "Usage: [file tail [info script]] inputDir cmd-relative-to-root...\n"
  exit 1
}

set inputDir [lindex $argv 0]
set cmd [lrange $argv 1 end]

set timeout 15

source [file join [file dirname [info script]] common.expect]

set testIndex 0
set testFailures 0

spawn {*}$cmd

foreach scenario [list \
  speech_recognize_once_from_mic \
  InvalidInput \
  Stop \
] {
  incr testIndex
  send_user "\n### Running test [set testIndex] - scenario [set scenario]\n"

  expect {
    "Your choice (0: Stop): " {

      switch $scenario {

        Stop {
          send 0
          expect {
            timeout {
              send_user "### TIMEOUT waiting for EOF\n"
              incr testFailures
            }
            eof
          }
        }

        InvalidInput {
          send x
          expect {
            timeout {
              send_user "### TIMEOUT waiting for Invalid input.\n"
              incr testFailures
            }
            "Invalid input."
          }
        }

        speech_recognize_once_from_mic {
          send 1
          expect {
            "Say something...\r\n" {
              paplay $weatherWav

              expect {
                -re "RECOGNIZED: Text=(\[^\r]*)\r\n" {
                  assertTextEqual testFailures "reco text" $weatherText $expect_out(1,string)
                }
                timeout {
                  send_user "### TIMEOUT waiting for RECOGNIZED\n"
                  incr testFailures
                }
              }
            }
            timeout {
              send_user "### TIMEOUT waiting for 'Say something'\n"
              incr testFailures
            }
          }
        }

        default {
          send_user "### invalid scenario, exiting\n"
          exit 1
        }
      }
    }
    timeout {
      # Didn't get the top-level prompt. Can't continue...
      send_user "### TIMEOUT waiting for prompt\n"
      exit 1
    }
  }
}

send_user "### Done -- [expr $testIndex - $testFailures]/$testIndex test(s) succeeded\n"

# Pick up error on program exit
lassign [wait] pid spawnid os_error_flag value
if {$os_error_flag == 0} {
  send_user "### sample exit status: $value\n"
  if {$value != 0} {
    send_user "### non-zero exit status\n"
    exit 1
  }
} else {
  send_user "### non-zero errno: $os_error_flag\n"
  exit 1
}

exit [set testFailures]

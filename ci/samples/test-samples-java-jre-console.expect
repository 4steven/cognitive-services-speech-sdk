#!/usr/bin/expect
#
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT license.
#

if {[llength $argv] < 2} {
  send_user "Usage: [file tail [info script]] inputDir cmd-relative-to-root...\n"
  exit 1
}

set inputDir [lindex $argv 0]
set cmd [lrange $argv 1 end]

set timeout 15

source [file join [file dirname [info script]] common.expect]

spawn {*}$cmd

set testIndex 0
set testFailures 0

proc selectMenuOption {option} {
  expect {
     timeout {
        send_user "### TIMEOUT waiting for menu prompt.\n"
        exit 1
     }
     "Your choice (0: Stop): "
  }
  send "$option\r"
}

# Note: use Stop exactly once, at the end of the list.
foreach scenario [list \
  SpeechRecognitionFromMicrophone \
  SpeechRecognitionFromMicrophone \
  IntentRecognitionWithMicrophone \
  InvalidInput \
  KeywordTriggeredSpeechRecognitionWithMicrophone \
  Stop \
] {
  incr testIndex
  send_user "\n### Running test [set testIndex] - scenario [set scenario]\n"

  switch $scenario {

    Stop {
      selectMenuOption 0
      expect {
        timeout {
          send_user "### TIMEOUT waiting for EOF\n"
          incr testFailures
        }
        eof
      }
    }

    InvalidInput {
      selectMenuOption x
      # Current sample just silently ignores.
    }

    SpeechRecognitionFromMicrophone {
      selectMenuOption 1
      expect {
        "Say something...\r\n" {
          paplay $weatherWav

          expect {
            -re "RECOGNIZED: Text=(\[^\r]*)\r\n" {
              assertTextEqual testFailures "reco text" $weatherText $expect_out(1,string)
            }
            timeout {
              send_user "### TIMEOUT waiting for RECOGNIZED\n"
              incr testFailures
            }
          }
        }
        timeout {
          send_user "### TIMEOUT waiting for 'Say something'\n"
          incr testFailures
        }
      }
    }

    IntentRecognitionWithMicrophone {
      selectMenuOption a
      expect {
        "Say something...\r\n" {
          paplay $turnOnTheLampWav

          expect {
            # Note: JSON isn't parsed just matched against. Note that for now it's multi-line.
            -re "RECOGNIZED: Text=(\[^\r]*)\r\n\\s*Intent Id: (\[^\r]*)\r\n\\s*Intent Service JSON:.*?\"intent\":\\s*\"(\[^\"]*)\"" {
              set failedAssertions 0
              assertTextEqual failedAssertions "reco text" $turnOnTheLampText $expect_out(1,string)
              assertTextEqual failedAssertions "mapped intent ID" $turnOnTheMappedLampIntent $expect_out(2,string)
              assertTextEqual failedAssertions "LUIS intent ID" $turnOnTheLampIntent $expect_out(3,string)
              if {$failedAssertions > 0} {
                incr testFailures
              }
            }
            timeout {
              send_user "### TIMEOUT waiting for RECOGNIZED\n"
              incr testFailures
            }
          }
        }
        timeout {
          send_user "### TIMEOUT waiting for 'Say something'\n"
          incr testFailures
        }
      }
    }

    KeywordTriggeredSpeechRecognitionWithMicrophone {
      selectMenuOption 6
      # TODO do a negative reco also
      expect {
        "Say something starting with" {
          set maxAttempts 3
          for {set attempt 1} {$attempt <= $maxAttempts} {incr attempt} {
            send_user "### Attempt $attempt\n"
            paplay $kwsWeatherWav [expr $attempt*1300]

            expect {
              -re "RECOGNIZED: Text=(\[^\r]*)\r\n" {
                assertTextNormalizedEqual testFailures "reco text" $kwsWeatherText $expect_out(1,string)
                break
              }
              "CANCELED: Reason=" {
                incr testFailures
                break
              }
              timeout {
                send_user "### TIMEOUT waiting for RECOGNIZED/CANCELED\n"
              }
            }
          }
          if {$attempt > $maxAttempts} {
             # No way to stop the sample.
             send_user "### Could not finish keyword-triggered recognition. Must stop.\n"
             exit 1
          }
        }
        timeout {
          send_user "### TIMEOUT waiting for 'Say something'\n"
          incr testFailures
          # likely a fatal error
        }
      }
    }

    default {
      send_user "### invalid scenario, exiting\n"
      exit 1
    }

  }
}

send_user "### Done -- [expr $testIndex - $testFailures]/$testIndex test(s) succeeded\n"

lassign [wait] pid spawnid os_error_flag value
if {$os_error_flag == 0} {
  send_user "### sample exit status: $value\n"
  if {$value != 0} {
    send_user "### non-zero exit status\n"
    exit 1
  }
} else {
  send_user "### non-zero errno: $os_error_flag\n"
  exit 1
}

exit [set testFailures]

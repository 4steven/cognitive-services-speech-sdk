#!/usr/bin/expect
#
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT license.
#
# This test script is used for testing various console-based quickstarts, which allow
# user to speak a phrase that the Speech SDK / Speech service will recognize.

if {[llength $argv] < 3} {
  send_user "Usage: [file tail [info script]] pathToAudio expectedRecoText cmd-relative-to-root...\n"
  exit 1
}

set pathToAudio [lindex $argv 0]
set expectedRecoText [lindex $argv 1]
set cmd [lrange $argv 2 end]

set timeout 15

set initialDelayMs 500
set matchRecoText "(?:We r|R)ecognized: (\[^\r]*)\r\n"

spawn {*}$cmd

# Wait for the prompt to happen

expect {
  default {
    send_user "### Timeout or EOF waiting for prompt\n"
    exit 1
  }
  "\\\[NbConvertApp\\\] Executing notebook with kernel: " {
    # "Prompt" for Jupyter notebooks, that aren't run interactively:
    # We just do "jupyter nbconvert" which outputs notebook content only when
    # done. Hence, we trigger for a status that comes up early, and allow a bit
    # more delay before playing the audio.
    set initialDelayMs 1500
    # Also, define a different regexp for matching the result.
    # N.B. be careful not to match the code!
    set matchRecoText " \"Recognized: (\[^\r]*)\\\\n\"\r\n"
  }
  "Say something..."
}

# Speak and check result

send_user "### Running paplay $pathToAudio\n"
after $initialDelayMs
exec paplay $pathToAudio

set failureCount 0
expect {
  -re $matchRecoText {
    set recoText $expect_out(1,string)
    if {$recoText eq $expectedRecoText} {
      send_user "### Pass with the right recognition text\n"
    } else {
      send_user "### BAD RECO TEXT: actual != expected: [set recoText] != [set expectedRecoText]\n"
      incr failureCount
    }
  }

  default {
    send_user "### Timeout or EOF waiting for result\n"
    exit 1
  }
}

# Exit

expect {
  "Please press a key to continue." {
    send "a\r"
    expect {
      timeout {
        send_user "### TIMEOUT waiting for EOF after hitting a key\n"
        exit 1
      }
      eof
    }
  }
  eof {
    # no prompt is fine, too.
  }
  timeout {
    send_user "### TIMEOUT waiting for key prompt or EOF\n"
    exit 1
  }
}

# Pick up error on program exit
lassign [wait] pid spawnid os_error_flag value
if {$os_error_flag == 0} {
  send_user "### sample exit status: $value\n"
  if {$value != 0} {
    send_user "### non-zero exit status\n"
    exit 1
  }
} else {
  send_user "### non-zero errno: $os_error_flag\n"
  exit 1
}

# If we've come so far, return the test failure count.
exit [set failureCount]

import sys, argparse, time, os.path

lib_dir = '${CMAKE_LIBRARY_OUTPUT_DIRECTORY}'
bin_dir = '${CMAKE_RUNTIME_OUTPUT_DIRECTORY}'

if ${TEST_PY_UNIX}:
    sys.path.append(lib_dir)
else:
    sys.path.append(lib_dir + '/Debug')
    sys.path.append(lib_dir + '/Release')
    import os
    os.environ['PATH'] = bin_dir + '/Debug;' + bin_dir + '/Release;' + ';' + os.environ['PATH']

from carbon_py import SpeechFactory, SessionEventCallback, SpeechRecognitionEventCallback
# TODO: #1137487

class _TestCallback(SessionEventCallback, SpeechRecognitionEventCallback):
    def __init__(self, msg):
        SessionEventCallback.__init__(self, self)
        SpeechRecognitionEventCallback.__init__(self, self)
        self.msg = msg
        self.num_calls = 0
    
    def __call__(self, event):
        self.num_calls += 1
        _print('{}: {}'.format(self.msg, event))

    def reset(self):
        self.num_calls = 0

callbacks = {
  'session_started' : _TestCallback('In session_started callback'),
  'session_stopped' : _TestCallback('In session_stopped callback'),
  'intermediate_result' : _TestCallback('In intermediate_result callback'),
  'final_result' : _TestCallback('In final_result callback'),
  'no_match' : _TestCallback('In no_match callback'),
  'canceled' : _TestCallback('In Canceled callback'),
}

def _assert(result):
    assert result
    assert result.text
    assert result.json
    assert callbacks['session_started'].num_calls == 1
    assert callbacks['session_stopped'].num_calls == 1
    assert callbacks['intermediate_result'].num_calls >= 1
    assert callbacks['final_result'].num_calls == 1

def test_recognize(subscription, filename, endpoint):
    result = recognize(subscription, filename=filename, endpoint=endpoint)
    _assert(result)

def test_recognize_async(subscription, filename, endpoint):
    result = recognize(subscription, endpoint=endpoint, filename=filename, async=True)
    _assert(result)

def _print(x): 
    new_line_x_3 = '\n'*3
    horizonal_line = '=' * 100
    sys.stdout.write('{0}{1}\n{2}\n{1}{0}'.format(new_line_x_3, horizonal_line, x))

def _connect(reco):
    for cb_name in callbacks:
        callback = callbacks[cb_name]
        callback.reset()
        getattr(reco, cb_name).connect(callback)

def _disconnect(reco):
    # BUGBUG #1180542
    # disconnect deadlocks, sleep instead:
    import time
    time.sleep(1)
    return
    for cb_name in callbacks:
        getattr(reco, cb_name).disconnect(callbacks[cb_name])

def recognize(subscription, endpoint=None, filename=None, async=False):
    if filename is not None:
        assert os.path.isfile(filename)

    if endpoint is not None:
        factory = SpeechFactory.from_endpoint(endpoint, subscription)
    else:
        factory = SpeechFactory.from_subscription(subscription, "")

    reco = factory.create_speech_recognizer(filename)

    _connect(reco)

    try:
        if not async:
            _print('Calling recognize()...')
            return reco.recognize()
        else:
            _print('Calling recognize_async()...')
            future = reco.recognize_async()
            _print('...recognize_async() in progress...')
            return future.get()
    finally:
        _disconnect(reco)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--filename')
    parser.add_argument('--subscription')
    parser.add_argument('--endpoint')
    parser.add_argument('--async', action="store_true")
    args = parser.parse_args()

    result = recognize(args.subscription, filename=args.filename, async=args.async, endpoint=args.endpoint)
    _print('Recognition complete: {}, (JSON: {})'.format(result, result.json))
